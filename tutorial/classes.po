# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2019, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Raphael Mendonça, 2017
# Claudio Rogerio, 2017
# msilvavieira, 2017
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.7\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2019-01-01 10:14+0900\n"
"PO-Revision-Date: 2017-02-16 23:39+0000\n"
"Last-Translator: msilvavieira, 2017\n"
"Language-Team: Portuguese (Brazil) (https://www.transifex.com/python-doc/"
"teams/5390/pt_BR/)\n"
"Language: pt_BR\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=2; plural=(n > 1);\n"

#: ../../tutorial/classes.rst:5
msgid "Classes"
msgstr "Classes"

#: ../../tutorial/classes.rst:7
msgid ""
"Classes provide a means of bundling data and functionality together.  "
"Creating a new class creates a new *type* of object, allowing new "
"*instances* of that type to be made.  Each class instance can have "
"attributes attached to it for maintaining its state.  Class instances can "
"also have methods (defined by its class) for modifying its state."
msgstr ""

#: ../../tutorial/classes.rst:13
msgid ""
"Compared with other programming languages, Python's class mechanism adds "
"classes with a minimum of new syntax and semantics.  It is a mixture of the "
"class mechanisms found in C++ and Modula-3.  Python classes provide all the "
"standard features of Object Oriented Programming: the class inheritance "
"mechanism allows multiple base classes, a derived class can override any "
"methods of its base class or classes, and a method can call the method of a "
"base class with the same name.  Objects can contain arbitrary amounts and "
"kinds of data.  As is true for modules, classes partake of the dynamic "
"nature of Python: they are created at runtime, and can be modified further "
"after creation."
msgstr ""
"Em comparação com outras linguagens, o mecanismo de classes de Python "
"introduz a programação orientada a objetos sem acrescentar muitas novidades "
"de sintaxe ou semântica. É uma mistura de mecanismos equivalentes "
"encontrados em C++ e Modula-3. As classes em Python oferecem todas as "
"características tradicionais da programação a orientada a objetos: o "
"mecanismo de herança permite múltiplas classes base (herança múltipla), uma "
"classe derivada pode sobrescrever quaisquer métodos de uma classe ancestral, "
"e um método pode invocar outro método homônimo de uma classe ancestral. "
"Objetos podem armazenar uma quantidade arbitrária de dados de qualquer tipo. "
"Assim como acontece com os módulos, as classes fazem parte da natureza "
"dinâmica de Python: são criadas em tempo de execução, e podem ser alteradas "
"após sua criação."

#: ../../tutorial/classes.rst:23
msgid ""
"In C++ terminology, normally class members (including the data members) are "
"*public* (except see below :ref:`tut-private`), and all member functions are "
"*virtual*.  As in Modula-3, there are no shorthands for referencing the "
"object's members from its methods: the method function is declared with an "
"explicit first argument representing the object, which is provided "
"implicitly by the call.  As in Smalltalk, classes themselves are objects.  "
"This provides semantics for importing and renaming.  Unlike C++ and "
"Modula-3, built-in types can be used as base classes for extension by the "
"user.  Also, like in C++, most built-in operators with special syntax "
"(arithmetic operators, subscripting etc.) can be redefined for class "
"instances."
msgstr ""
"Usando a terminologia de C++, todos os membros de uma classe (incluindo "
"dados) são públicos, e todos as funções membro são virtuais. Como em "
"Modula-3, não existem atalhos para referenciar membros do objeto de dentro "
"dos seus métodos. Um método (função definida em uma classe) é declarado com "
"um primeiro argumento explícito representando o objeto (instância da "
"classe), que é fornecido implicitamente pela invocação. Como em Smalltalk, "
"classes são objetos. Isso fornece uma semântica para importar e renomear. Ao "
"contrário de C++ ou Modula-3, tipos pré-definidos podem ser utilizados como "
"classes base para extensões de usuário por herança. Como em C++, mas "
"diferentemente de Modula-3, a maioria dos operadores (aritméticos, indexação,"
"etc) podem ser redefinidos para instâncias de classe."

#: ../../tutorial/classes.rst:34
msgid ""
"(Lacking universally accepted terminology to talk about classes, I will make "
"occasional use of Smalltalk and C++ terms.  I would use Modula-3 terms, "
"since its object-oriented semantics are closer to those of Python than C++, "
"but I expect that few readers have heard of it.)"
msgstr ""
"(Na falta de uma terminologia universalmente aceita para falar sobre "
"classes, ocasionalmente farei uso de termos comuns em Smalltalk ou C++. Eu "
"usaria termos de Modula-3, já que sua semântica é mais próxima a de Python, "
"mas creio que poucos leitores já ouviram falar dessa linguagem.)"

#: ../../tutorial/classes.rst:43
msgid "A Word About Names and Objects"
msgstr "Uma palavra Sobre Nomes e Objetos"

#: ../../tutorial/classes.rst:45
msgid ""
"Objects have individuality, and multiple names (in multiple scopes) can be "
"bound to the same object.  This is known as aliasing in other languages.  "
"This is usually not appreciated on a first glance at Python, and can be "
"safely ignored when dealing with immutable basic types (numbers, strings, "
"tuples).  However, aliasing has a possibly surprising effect on the "
"semantics of Python code involving mutable objects such as lists, "
"dictionaries, and most other types. This is usually used to the benefit of "
"the program, since aliases behave like pointers in some respects.  For "
"example, passing an object is cheap since only a pointer is passed by the "
"implementation; and if a function modifies an object passed as an argument, "
"the caller will see the change --- this eliminates the need for two "
"different argument passing mechanisms as in Pascal."
msgstr ""
"Objetos têm individualidade, e vários nomes (inclusive em diferentes "
"escopos) podem estar vinculados a um mesmo objeto. Isso é chamado de "
"*aliasing* em outras linguagens. (N.d.T. *aliasing* é, literalmente, "
"\"apelidamento\": um mesmo objeto pode ter vários apelidos.) À primeira "
"vista, esta característica não é muito apreciada, e pode ser seguramente "
"ignorada ao lidar com tipos imutáveis (números, strings, tuplas). "
"Entretanto, aliasing pode ter um efeito inesperado sobre a semântica de "
"código Python envolvendo objetos mutáveis como listas, dicionários e a "
"maioria dos outros tipos. Isso pode ser usado em benefício do programa, "
"porque os *aliases* (apelidos) funcionam de certa forma como ponteiros. Por "
"exemplo, passar um objeto como argumento é barato, pois só um ponteiro é "
"passado na implementação; e se uma função modifica um objeto passado como "
"argumento, o invocador verá a mudança --- isso elimina a necessidade de ter "
"dois mecanismos de passagem de parâmetros como em Pascal. ( Nota do "
"Tradutor: na terminologia de C++ e Java, o que o parágrafo acima denomina "
"\"apelidos\" são identificadores de referências (variáveis de referência), e "
"os ponteiros são as próprias referências. Se uma variável ``a`` está "
"associada a um objeto qualquer, informalmente dizemos que a variável \"contém"
"\" o objeto, mas na realidade o objeto existe independente da variável, e o "
"conteúdo da variável é apenas uma referência (um ponteiro) para o objeto. O "
"*aliasing* ocorre quando existem diversas variáveis, digamos ``a``, ``b`` e "
"``c``, apontando para o mesmo objeto.)"

#: ../../tutorial/classes.rst:61
msgid "Python Scopes and Namespaces"
msgstr "Escopos e Namespaces do Python"

#: ../../tutorial/classes.rst:63
msgid ""
"Before introducing classes, I first have to tell you something about "
"Python's scope rules.  Class definitions play some neat tricks with "
"namespaces, and you need to know how scopes and namespaces work to fully "
"understand what's going on. Incidentally, knowledge about this subject is "
"useful for any advanced Python programmer."
msgstr ""
"Antes de introduzir classes, é preciso falar das regras de escopo em Python. "
"Definições de classe fazem alguns truques com *namespaces* (espaços de "
"nomes). Portanto, primeiro é preciso entender claramente como escopos e "
"*namespaces* funcionam. Esse conhecimento é muito útil para o programador "
"avançado em Python."

#: ../../tutorial/classes.rst:69
msgid "Let's begin with some definitions."
msgstr "Vamos começar com algumas definições."

#: ../../tutorial/classes.rst:71
msgid ""
"A *namespace* is a mapping from names to objects.  Most namespaces are "
"currently implemented as Python dictionaries, but that's normally not "
"noticeable in any way (except for performance), and it may change in the "
"future.  Examples of namespaces are: the set of built-in names (containing "
"functions such as :func:`abs`, and built-in exception names); the global "
"names in a module; and the local names in a function invocation.  In a sense "
"the set of attributes of an object also form a namespace.  The important "
"thing to know about namespaces is that there is absolutely no relation "
"between names in different namespaces; for instance, two different modules "
"may both define a function ``maximize`` without confusion --- users of the "
"modules must prefix it with the module name."
msgstr ""
"Um *namespace* (ou espaço de nomes) é um mapeamento que associa nomes a "
"objetos. Atualmente, são implementados como dicionários em Python, mas isso "
"não é perceptível (a não ser pelo desempenho), e pode mudar no futuro. "
"Exemplos de espaços de nomes são: o conjunto de nomes pré-definidos (funções "
"como :func:`abs` e as exceções embutidas); nomes globais em um módulo; e "
"nomes locais na invocação de uma função. De uma certa forma, os atributos de "
"um objeto também formam um espaço de nomes. O mais importante é saber que "
"não existe nenhuma relação entre nomes em espaços distintos. Por exemplo, "
"dois módulos podem definir uma função de nome ``maximize`` sem confusão --- "
"usuários dos módulos devem prefixar a função com o nome do módulo para "
"evitar colisão."

#: ../../tutorial/classes.rst:82
msgid ""
"By the way, I use the word *attribute* for any name following a dot --- for "
"example, in the expression ``z.real``, ``real`` is an attribute of the "
"object ``z``.  Strictly speaking, references to names in modules are "
"attribute references: in the expression ``modname.funcname``, ``modname`` is "
"a module object and ``funcname`` is an attribute of it.  In this case there "
"happens to be a straightforward mapping between the module's attributes and "
"the global names defined in the module: they share the same namespace!  [#]_"
msgstr ""
"A propósito, utilizo a palavra *atributo* para qualquer nome depois de um "
"ponto. Na expressão ``z.real``, por exemplo, ``real`` é um atributo do "
"objeto ``z``. Estritamente falando, referências para nomes em módulos são "
"atributos: na expressão ``nomemod.nomefunc``, ``nomemod`` é um objeto módulo "
"e ``nomefunc`` é um de seus atributos. Neste caso, existe um mapeamento "
"direto entre os atributos de um módulo e os nomes globais definidos no "
"módulo: eles compartilham o mesmo espaço de nomes! [#]_"

#: ../../tutorial/classes.rst:90
msgid ""
"Attributes may be read-only or writable.  In the latter case, assignment to "
"attributes is possible.  Module attributes are writable: you can write "
"``modname.the_answer = 42``.  Writable attributes may also be deleted with "
"the :keyword:`del` statement.  For example, ``del modname.the_answer`` will "
"remove the attribute :attr:`the_answer` from the object named by ``modname``."
msgstr ""
"Atributos podem ser somente para leitura ou para leitura e escrita. No "
"segundo caso, é possível atribuir um novo valor ao atributo. (N.d.T. Também "
"é possível criar novos atributos.) Atributos de módulos são passíveis de "
"atribuição: você pode escrever ``nomemod.a_reposta = 42``. Atributos que "
"aceitam escrita também podem ser apagados através do comando :keyword:`del`. "
"Por exemplo, ``del nomemod.a_reposta`` remove o atributo :attr:`a_resposta` "
"do objeto referenciado por ``nomemod``."

#: ../../tutorial/classes.rst:96
msgid ""
"Namespaces are created at different moments and have different lifetimes.  "
"The namespace containing the built-in names is created when the Python "
"interpreter starts up, and is never deleted.  The global namespace for a "
"module is created when the module definition is read in; normally, module "
"namespaces also last until the interpreter quits.  The statements executed "
"by the top-level invocation of the interpreter, either read from a script "
"file or interactively, are considered part of a module called :mod:"
"`__main__`, so they have their own global namespace.  (The built-in names "
"actually also live in a module; this is called :mod:`builtins`.)"
msgstr ""
"Espaços de nomes são criados em momentos diferentes e possuem diferentes "
"ciclos de vida. O espaço de nomes que contém os nomes embutidos é criado "
"quando o interpretador inicializa e nunca é removido. O espaço de nomes "
"global de um módulo é criado quando a definição do módulo é lida, e "
"normalmente duram até a terminação do interpretador. Os comandos executados "
"pela invocação do interpretador, pela leitura de um script com programa "
"principal, ou interativamente, são parte do módulo chamado :mod:`__main__`, "
"e portanto possuem seu próprio espaço de nomes. (Os nomes embutidos possuem "
"seu próprio espaço de nomes no módulo chamado :mod:`builtin`.)."

#: ../../tutorial/classes.rst:106
msgid ""
"The local namespace for a function is created when the function is called, "
"and deleted when the function returns or raises an exception that is not "
"handled within the function.  (Actually, forgetting would be a better way to "
"describe what actually happens.)  Of course, recursive invocations each have "
"their own local namespace."
msgstr ""
"O espaço de nomes local de uma função é criado quando a função é invocada, e "
"apagado quando a função retorna ou levanta uma exceção que não é tratada na "
"própria função. (Na verdade, uma forma melhor de descrever o que realmente "
"acontece é que o espaço de nomes local é \"esquecido\" quando a função "
"termina.) Naturalmente, cada invocação recursiva de uma função tem seu "
"próprio espaço de nomes."

#: ../../tutorial/classes.rst:112
msgid ""
"A *scope* is a textual region of a Python program where a namespace is "
"directly accessible.  \"Directly accessible\" here means that an unqualified "
"reference to a name attempts to find the name in the namespace."
msgstr ""
"Um *escopo* (*scope*) é uma região textual de um programa Python onde um "
"espaço de nomes é diretamente acessível. Aqui, \"diretamente acessível\" "
"significa que uma referência sem um prefixo qualificador permite o acesso ao "
"nome."

#: ../../tutorial/classes.rst:116
msgid ""
"Although scopes are determined statically, they are used dynamically. At any "
"time during execution, there are at least three nested scopes whose "
"namespaces are directly accessible:"
msgstr ""
"Ainda que escopos sejam determinados estaticamente, eles são usados "
"dinamicamente. A qualquer momento durante a execução, existem no mínimo três "
"escopos diretamente acessíveis:"

#: ../../tutorial/classes.rst:120
msgid "the innermost scope, which is searched first, contains the local names"
msgstr ""
"* o escopo mais interno (que é acessado primeiro) contendo nomes locais;"

#: ../../tutorial/classes.rst:121
msgid ""
"the scopes of any enclosing functions, which are searched starting with the "
"nearest enclosing scope, contains non-local, but also non-global names"
msgstr ""
"* os escopos das funções que envolvem a função atual, que são acessados a "
"partir do escopo mias próximo, contém nomes não-locais mas também não-"
"globais;"

#: ../../tutorial/classes.rst:123
msgid "the next-to-last scope contains the current module's global names"
msgstr "* o penúltimo escopo contém os nomes globais do módulo atual;"

#: ../../tutorial/classes.rst:124
msgid ""
"the outermost scope (searched last) is the namespace containing built-in "
"names"
msgstr ""
"* e o escopo mais externo (acessado por último) contém os nomes das funções "
"embutidas e demais objetos pré-definidos do interpretador."

#: ../../tutorial/classes.rst:126
msgid ""
"If a name is declared global, then all references and assignments go "
"directly to the middle scope containing the module's global names.  To "
"rebind variables found outside of the innermost scope, the :keyword:"
"`nonlocal` statement can be used; if not declared nonlocal, those variables "
"are read-only (an attempt to write to such a variable will simply create a "
"*new* local variable in the innermost scope, leaving the identically named "
"outer variable unchanged)."
msgstr ""
"Se um nome é declarado no escopo global, então todas as referências e "
"atribuições valores vão diretamente para o escopo intermediário que contém "
"os nomes globais do módulo. Caso contrário, todas as variáveis encontradas "
"fora do escopo mais interno são apenas para leitura (a tentativa de atribuir "
"valores a essas variáveis irá simplesmente criar uma *nova* variável local, "
"no escopo interno, não alterando nada na variável de nome idêntico fora "
"dele)."

#: ../../tutorial/classes.rst:133
msgid ""
"Usually, the local scope references the local names of the (textually) "
"current function.  Outside functions, the local scope references the same "
"namespace as the global scope: the module's namespace. Class definitions "
"place yet another namespace in the local scope."
msgstr ""
"Normalmente, o escopo local referencia os nomes locais da função corrente no "
"texto do programa. Fora de funções, o escopo local referencia os nomes do "
"escopo global: espaço de nomes do módulo. Definições de classes adicionam um "
"outro espaço de nomes ao escopo local."

#: ../../tutorial/classes.rst:138
msgid ""
"It is important to realize that scopes are determined textually: the global "
"scope of a function defined in a module is that module's namespace, no "
"matter from where or by what alias the function is called.  On the other "
"hand, the actual search for names is done dynamically, at run time --- "
"however, the language definition is evolving towards static name resolution, "
"at \"compile\" time, so don't rely on dynamic name resolution!  (In fact, "
"local variables are already determined statically.)"
msgstr ""
"É importante perceber que escopos são determinados estaticamente, pelo texto "
"do código fonte: o escopo global de uma função definida em um módulo é o "
"espaço de nomes deste módulo, sem importar de onde ou por qual apelido a "
"função é invocada. Por outro lado, a busca de nomes é dinâmica, ocorrendo "
"durante a execução. Porém, a evolução da linguagem está caminhando para uma "
"resolução de nomes estática, em \"tempo de compilação\" (N.d.T. quando um "
"módulo é carregado ele é compilado em memória), portanto não conte com a "
"resolução dinâmica de nomes! (De fato, variáveis locais já são resolvidas "
"estaticamente.)"

#: ../../tutorial/classes.rst:146
msgid ""
"A special quirk of Python is that -- if no :keyword:`global` statement is in "
"effect -- assignments to names always go into the innermost scope.  "
"Assignments do not copy data --- they just bind names to objects.  The same "
"is true for deletions: the statement ``del x`` removes the binding of ``x`` "
"from the namespace referenced by the local scope.  In fact, all operations "
"that introduce new names use the local scope: in particular, :keyword:"
"`import` statements and function definitions bind the module or function "
"name in the local scope."
msgstr ""
"Uma peculiaridade de Python é que atribuições ocorrem sempre no escopo mais "
"interno, exceto quando o comando :keyword:`global` é usado. Atribuições não "
"copiam dados, apenas associam nomes a objetos. O mesmo vale para remoções: o "
"comando ``del x`` remove o vínculo de ``x`` do espaço de nomes do escopo "
"local. De fato, todas as operações que introduzem novos nomes usam o escopo "
"local. Em particular, instruções :keyword:`import` e definições de funções "
"associam o nome módulo ou da função ao escopo local."

#: ../../tutorial/classes.rst:154
msgid ""
"The :keyword:`global` statement can be used to indicate that particular "
"variables live in the global scope and should be rebound there; the :keyword:"
"`nonlocal` statement indicates that particular variables live in an "
"enclosing scope and should be rebound there."
msgstr ""
"A palavra reservada :keyword:`global` pode ser usada para indicar que certas "
"variáveis residem no escopo global ao invés do local; a instrução :keyword:"
"`nonlocal` indica que variáveis particulares estão num espaço reservado e "
"devem ser recuperadas lá."

#: ../../tutorial/classes.rst:162
msgid "Scopes and Namespaces Example"
msgstr "Exemplo de Escopos e Namespaces"

#: ../../tutorial/classes.rst:164
msgid ""
"This is an example demonstrating how to reference the different scopes and "
"namespaces, and how :keyword:`global` and :keyword:`nonlocal` affect "
"variable binding::"
msgstr ""
"Este é um exemplo que demonstra como se referir aos diferentes espaços e aos "
"espaços de nomes como :keyword:`global` e :keyword:`non-local' pode afetar "
"ligação entre as variáveis::"

#: ../../tutorial/classes.rst:191
msgid "The output of the example code is:"
msgstr "A saída do código de exemplo é:"

#: ../../tutorial/classes.rst:200
msgid ""
"Note how the *local* assignment (which is default) didn't change *scope_test*"
"\\'s binding of *spam*.  The :keyword:`nonlocal` assignment changed "
"*scope_test*\\'s binding of *spam*, and the :keyword:`global` assignment "
"changed the module-level binding."
msgstr ""
"Observe como uma atribuição *local* (que é o padrão) não altera o "
"*scope_test*\\'s vinculado a *spam*. A atribuição :keyworkd:`nonlocal` mudou "
"o *scope_test* vinculo de *spam* e a :keyword:`global` alterou a ligação do "
"nível do módulo."

#: ../../tutorial/classes.rst:205
msgid ""
"You can also see that there was no previous binding for *spam* before the :"
"keyword:`global` assignment."
msgstr ""

#: ../../tutorial/classes.rst:212
msgid "A First Look at Classes"
msgstr "Uma Primeira Olhada nas Classes"

#: ../../tutorial/classes.rst:214
msgid ""
"Classes introduce a little bit of new syntax, three new object types, and "
"some new semantics."
msgstr ""
"As classes introduzem um pouco de nova sintaxe, três novos tipos de objeto e "
"algumas semânticas novas."

#: ../../tutorial/classes.rst:221
msgid "Class Definition Syntax"
msgstr "Definição  da Sintaxe das Classe"

#: ../../tutorial/classes.rst:223
msgid "The simplest form of class definition looks like this::"
msgstr "A forma mais simples de definição de classe se parece com isto::"

#: ../../tutorial/classes.rst:232
msgid ""
"Class definitions, like function definitions (:keyword:`def` statements) "
"must be executed before they have any effect.  (You could conceivably place "
"a class definition in a branch of an :keyword:`if` statement, or inside a "
"function.)"
msgstr ""
"Definições de classes, assim como definições de funções (instruções\n"
":keyword:`def`), precisam ser executados antes que tenham qualquer efeito.\n"
"(Por exemplo, você pode colocar uma definição de classe dentro de teste\n"
"condicional :keyword:`if` ou dentro de uma função.)"

#: ../../tutorial/classes.rst:236
msgid ""
"In practice, the statements inside a class definition will usually be "
"function definitions, but other statements are allowed, and sometimes useful "
"--- we'll come back to this later.  The function definitions inside a class "
"normally have a peculiar form of argument list, dictated by the calling "
"conventions for methods --- again, this is explained later."
msgstr ""
"Na prática, as instruções dentro da definição de uma classe em geral serão\n"
"definições de funções, mas outras instruções são permitidas, e às vezes são\n"
"bem úteis --- voltaremos a este tema depois. Definições de funções dentro "
"da\n"
"classe normalmente têm um lista peculiar de parâmetros formais determinada\n"
"pela convenção de chamada a métodos --- isso também será explicado mais "
"tarde."

#: ../../tutorial/classes.rst:242
msgid ""
"When a class definition is entered, a new namespace is created, and used as "
"the local scope --- thus, all assignments to local variables go into this "
"new namespace.  In particular, function definitions bind the name of the new "
"function here."
msgstr ""
"Quando se inicia a definição de classe, um novo namespace é criado, e usado\n"
"como escopo local --- assim, todas atribuições a variáveis locais ocorrem\n"
"nesse namespace. Em particular, funções definidas aqui são vinculadas a "
"nomes\n"
"nesse escopo."

#: ../../tutorial/classes.rst:247
msgid ""
"When a class definition is left normally (via the end), a *class object* is "
"created.  This is basically a wrapper around the contents of the namespace "
"created by the class definition; we'll learn more about class objects in the "
"next section.  The original local scope (the one in effect just before the "
"class definition was entered) is reinstated, and the class object is bound "
"here to the class name given in the class definition header (:class:"
"`ClassName` in the example)."
msgstr ""
"Quando o processamento de uma definição de classe é completado "
"(normalmente,\n"
"sem erros), um *objeto classe* é criado. Este objeto encapsula o conteúdo "
"do\n"
"espaço de nomes criado pela definição da classe; aprenderemos mais sobre\n"
"objetos classe na próxima seção. O escopo local que estava vigente antes da\n"
"definição da classe é reativado, e o objeto classe é vinculado ao\n"
"identificador da classe nesse escopo (no exemplo acima, :class:"
"`NomeDaClasse`\n"
"é o identificador da classe)."

#: ../../tutorial/classes.rst:259
msgid "Class Objects"
msgstr "Objetos de Classe"

#: ../../tutorial/classes.rst:261
msgid ""
"Class objects support two kinds of operations: attribute references and "
"instantiation."
msgstr ""
"Objetos classe suportam dois tipos de operações: *referências a atributos* "
"e\n"
"*instanciação*."

#: ../../tutorial/classes.rst:264
msgid ""
"*Attribute references* use the standard syntax used for all attribute "
"references in Python: ``obj.name``.  Valid attribute names are all the names "
"that were in the class's namespace when the class object was created.  So, "
"if the class definition looked like this::"
msgstr ""
"*Referências a atributos* de classe utilizam a sintaxe padrão utilizada "
"para\n"
"quaisquer referências a atributos em Python: ``obj.nome``. Atributos "
"válidos\n"
"são todos os nomes presentes dentro do namespace da classe quando o objeto\n"
"classe foi criado. Portanto, se a definição da classe foi assim::"

#: ../../tutorial/classes.rst:276
msgid ""
"then ``MyClass.i`` and ``MyClass.f`` are valid attribute references, "
"returning an integer and a function object, respectively. Class attributes "
"can also be assigned to, so you can change the value of ``MyClass.i`` by "
"assignment. :attr:`__doc__` is also a valid attribute, returning the "
"docstring belonging to the class: ``\"A simple example class\"``."
msgstr ""
"então ``MinhaClasse.i`` e ``MinhaClasse.f`` são referências válidas, que\n"
"acessam, respectivamente, um inteiro e um objeto função. É possível mudar "
"os\n"
"valores dos atributos da classe, ou mesmo criar novos atributos, fazendo "
"uma\n"
"atribuição simples assim: ``MinhaClasse.i = 10``. O nome ``__doc__``\n"
"identifica outro atributo válido da classe, referenciando a *docstring*\n"
"associada à ela: ``\"Um exemplo simples de classe\"``."

#: ../../tutorial/classes.rst:282
msgid ""
"Class *instantiation* uses function notation.  Just pretend that the class "
"object is a parameterless function that returns a new instance of the class. "
"For example (assuming the above class)::"
msgstr ""
"Para *instanciar* uma classe, usa-se a sintaxe de invocar uma função. "
"Apenas\n"
"finja que o objeto classe do exemplo é uma função sem parâmetros, que "
"devolve\n"
"uma nova instância da classe. Continuando o exemplo acima:"

#: ../../tutorial/classes.rst:288
msgid ""
"creates a new *instance* of the class and assigns this object to the local "
"variable ``x``."
msgstr ""
"cria uma nova *instância* da classe e atribui o objeto resultante à "
"variável\n"
"local ``x``."

#: ../../tutorial/classes.rst:291
msgid ""
"The instantiation operation (\"calling\" a class object) creates an empty "
"object. Many classes like to create objects with instances customized to a "
"specific initial state. Therefore a class may define a special method named :"
"meth:`__init__`, like this::"
msgstr ""
"A operação de instanciação (\"invocar\" um objeto classe) cria um objeto "
"vazio.\n"
"Muitas classes preferem criar novos objetos com um estado inicial\n"
"predeterminado. Para tanto, a classe pode definir um método especial\n"
"chamado :meth:`__init__`, assim::"

#: ../../tutorial/classes.rst:299
msgid ""
"When a class defines an :meth:`__init__` method, class instantiation "
"automatically invokes :meth:`__init__` for the newly-created class "
"instance.  So in this example, a new, initialized instance can be obtained "
"by::"
msgstr ""
"Quando uma classe define um método :meth:`__init__`, o processo de\n"
"instanciação automaticamente invoca :meth:`__init__` sobre a instância "
"recém\n"
"criada. Em nosso exemplo, uma nova instância já inicializada pode ser "
"obtida\n"
"desta maneira::"

#: ../../tutorial/classes.rst:305
msgid ""
"Of course, the :meth:`__init__` method may have arguments for greater "
"flexibility.  In that case, arguments given to the class instantiation "
"operator are passed on to :meth:`__init__`.  For example, ::"
msgstr ""
"Naturalmente, o método :meth:`__init__` pode ter parâmetros para maior\n"
"flexibilidade. Neste caso, os argumentos fornecidos na invocação da classe\n"
"serão passados para o método :meth:`__init__`. Por exemplo::"

#: ../../tutorial/classes.rst:322
msgid "Instance Objects"
msgstr "Objetos de Instância"

#: ../../tutorial/classes.rst:324
msgid ""
"Now what can we do with instance objects?  The only operations understood by "
"instance objects are attribute references.  There are two kinds of valid "
"attribute names, data attributes and methods."
msgstr ""
"Agora, o que podemos fazer com instâncias? As únicas operações reconhecidas\n"
"por instâncias são referências a atributos. Existem dois tipos de nomes de\n"
"atributos válidos: atributos de dados (*data attributes*) e métodos."

#: ../../tutorial/classes.rst:328
msgid ""
"*data attributes* correspond to \"instance variables\" in Smalltalk, and to "
"\"data members\" in C++.  Data attributes need not be declared; like local "
"variables, they spring into existence when they are first assigned to.  For "
"example, if ``x`` is the instance of :class:`MyClass` created above, the "
"following piece of code will print the value ``16``, without leaving a "
"trace::"
msgstr ""
"Atributos de dados correspondem a \"variáveis de instância\" em Smalltalk, e "
"a\n"
"\"data members\" em C++. Atributos de dados não precisam ser declarados.\n"
"Assim como variáveis locais, eles passam a existir na primeira vez em que é\n"
"feita uma atribuição. Por exemplo, se ``x`` é uma instância da\n"
":class:`MinhaClasse` criada acima, o próximo trecho de código irá exibir o\n"
"valor ``16``, sem deixar nenhum rastro na instância (por causa do uso de\n"
":keyword:`del`)::"

#: ../../tutorial/classes.rst:340
msgid ""
"The other kind of instance attribute reference is a *method*. A method is a "
"function that \"belongs to\" an object.  (In Python, the term method is not "
"unique to class instances: other object types can have methods as well.  For "
"example, list objects have methods called append, insert, remove, sort, and "
"so on. However, in the following discussion, we'll use the term method "
"exclusively to mean methods of class instance objects, unless explicitly "
"stated otherwise.)"
msgstr ""
"O outro tipo de referências a atributos são métodos. Um método é uma função\n"
"que \"pertence\" a uma instância. (Em Python, o termo método não é aplicado\n"
"exclusivamente a instâncias de classes definidas pelo usuário: outros tipos "
"de\n"
"objetos também podem ter métodos. Por exemplo, listas possuem os métodos\n"
"append, insert, remove, sort, etc. Porém, na discussão a seguir usaremos o\n"
"termo método apenas para se referir a métodos de classes definidas pelo\n"
"usuário. Seremos explícitos ao falar de outros métodos.)"

#: ../../tutorial/classes.rst:349
msgid ""
"Valid method names of an instance object depend on its class.  By "
"definition, all attributes of a class that are function  objects define "
"corresponding methods of its instances.  So in our example, ``x.f`` is a "
"valid method reference, since ``MyClass.f`` is a function, but ``x.i`` is "
"not, since ``MyClass.i`` is not.  But ``x.f`` is not the same thing as "
"``MyClass.f`` --- it is a *method object*, not a function object."
msgstr ""
"Nomes de métodos válidos de uma instância dependem de sua classe. Por "
"definição, cada atributo de uma classe que é uma função corresponde a um "
"método das instâncias. Em nosso exemplo, ``x.f`` é uma referência de método "
"válida já que ``MinhaClasse.f`` é uma função, enquanto ``x.i`` não é, já que "
"``MinhaClasse.i`` não é uma função. Entretanto, ``x.f`` não é o mesmo que "
"``MinhaClasse.f``. A referência ``x.f`` acessa um objeto método (*method "
"object*), e a ``MinhaClasse.f`` acessa um objeto função."

#: ../../tutorial/classes.rst:360
msgid "Method Objects"
msgstr "Objetos de Método"

#: ../../tutorial/classes.rst:362
msgid "Usually, a method is called right after it is bound::"
msgstr "Normalmente, um método é invocado imediatamente após ser acessado::"

#: ../../tutorial/classes.rst:366
msgid ""
"In the :class:`MyClass` example, this will return the string ``'hello "
"world'``. However, it is not necessary to call a method right away: ``x.f`` "
"is a method object, and can be stored away and called at a later time.  For "
"example::"
msgstr ""
"No exemplo :class:`MinhaClasse` o resultado da expressão acima será a "
"string\n"
"``'olá, mundo'``. No entanto, não é obrigatório invocar o método\n"
"imediatamente: como ``x.f`` é também um objeto (um objeto método), ele pode\n"
"atribuído a uma variável invocado depois. Por exemplo::"

#: ../../tutorial/classes.rst:374
msgid "will continue to print ``hello world`` until the end of time."
msgstr "Esse código exibirá o texto ``'olá, mundo'`` até o mundo acabar."

#: ../../tutorial/classes.rst:376
msgid ""
"What exactly happens when a method is called?  You may have noticed that ``x."
"f()`` was called without an argument above, even though the function "
"definition for :meth:`f` specified an argument.  What happened to the "
"argument? Surely Python raises an exception when a function that requires an "
"argument is called without any --- even if the argument isn't actually "
"used..."
msgstr ""
"O que ocorre precisamente quando um método é invocado? Você deve ter notado\n"
"que ``x.f()`` foi chamado sem nenhum parâmetro, porém a definição da função\n"
":meth:`f` especificava um parâmetro. O que aconteceu com esse parâmetro?\n"
"Certamente Python levanta uma exceção quando uma função que declara um\n"
"parâmetro é invocada sem nenhum argumento --- mesmo que o argumento não\n"
"seja usado no corpo da função..."

#: ../../tutorial/classes.rst:382
msgid ""
"Actually, you may have guessed the answer: the special thing about methods "
"is that the instance object is passed as the first argument of the "
"function.  In our example, the call ``x.f()`` is exactly equivalent to "
"``MyClass.f(x)``.  In general, calling a method with a list of *n* arguments "
"is equivalent to calling the corresponding function with an argument list "
"that is created by inserting the method's instance object before the first "
"argument."
msgstr ""
"Talvez você já tenha adivinhado a resposta: o que os métodos têm de especial "
"é\n"
"que eles passam o objeto (ao qual o método está vinculado) como primeiro\n"
"argumento da função definida na classe. No nosso exemplo, a chamada ``x."
"f()``\n"
"equivale exatamente ``MinhaClasse.f(x)``. Em geral, chamar um método com "
"uma\n"
"lista de *n* argumentos é equivalente a chamar a função na classe\n"
"correspondente passando a instância como o primeiro argumento antes dos "
"demais\n"
"*n* argumentos."

#: ../../tutorial/classes.rst:389
msgid ""
"If you still don't understand how methods work, a look at the implementation "
"can perhaps clarify matters.  When a non-data attribute of an instance is "
"referenced, the instance's class is searched.  If the name denotes a valid "
"class attribute that is a function object, a method object is created by "
"packing (pointers to) the instance object and the function object just found "
"together in an abstract object: this is the method object.  When the method "
"object is called with an argument list, a new argument list is constructed "
"from the instance object and the argument list, and the function object is "
"called with this new argument list."
msgstr ""

#: ../../tutorial/classes.rst:403
msgid "Class and Instance Variables"
msgstr "Variáveis de Classe e Instância"

#: ../../tutorial/classes.rst:405
msgid ""
"Generally speaking, instance variables are for data unique to each instance "
"and class variables are for attributes and methods shared by all instances "
"of the class::"
msgstr ""
"De forma geral, variáveis de instância são variáveis que indicam dados que "
"são únicos a cada instância individual, e variáveis de classe são variáveis "
"de atributos e de métodos que são comuns a todas as instâncias de uma "
"classe::"

#: ../../tutorial/classes.rst:427
msgid ""
"As discussed in :ref:`tut-object`, shared data can have possibly surprising "
"effects with involving :term:`mutable` objects such as lists and "
"dictionaries. For example, the *tricks* list in the following code should "
"not be used as a class variable because just a single list would be shared "
"by all *Dog* instances::"
msgstr ""
"Como vimos em :ref:`tut-object`, o compartilhamento de dados pode causar "
"efeitos inesperados quando envolve objetos mutáveis (em inglês: :term:"
"`mutable` objects), como listas ou dicionários. Por exemplo, a lista "
"*tricks* do código abaixo não deve ser usada como variável de classe, pois "
"assim seria compartilhada por todas as instâncias de *Dog*::"

#: ../../tutorial/classes.rst:450
msgid "Correct design of the class should use an instance variable instead::"
msgstr ""
"Em vez disso, o design correto da classe emprega uma variável de instância::"

#: ../../tutorial/classes.rst:474
msgid "Random Remarks"
msgstr "Observações Aleatórias"

#: ../../tutorial/classes.rst:478
msgid ""
"Data attributes override method attributes with the same name; to avoid "
"accidental name conflicts, which may cause hard-to-find bugs in large "
"programs, it is wise to use some kind of convention that minimizes the "
"chance of conflicts.  Possible conventions include capitalizing method "
"names, prefixing data attribute names with a small unique string (perhaps "
"just an underscore), or using verbs for methods and nouns for data "
"attributes."
msgstr ""
"Atributos de dados sobrescrevem atributos métodos homônimos. Para evitar\n"
"conflitos de nome acidentais, que podem gerar bugs de difícil rastreio em\n"
"programas extensos, é sábio adotar algum tipo de convenção que minimize a\n"
"chance de conflitos. Convenções comuns incluem: definir nomes de métodos "
"com\n"
"inicial maiúscula, prefixar atributos de dados com uma string única (quem "
"sabe\n"
"\"_\" [*underscore* ou sublinhado]), ou usar sempre verbos para nomear "
"métodos\n"
"e substantivos para atributos de dados."

#: ../../tutorial/classes.rst:485
msgid ""
"Data attributes may be referenced by methods as well as by ordinary users "
"(\"clients\") of an object.  In other words, classes are not usable to "
"implement pure abstract data types.  In fact, nothing in Python makes it "
"possible to enforce data hiding --- it is all based upon convention.  (On "
"the other hand, the Python implementation, written in C, can completely hide "
"implementation details and control access to an object if necessary; this "
"can be used by extensions to Python written in C.)"
msgstr ""
"Atributos de dados podem ser referenciados por métodos da própria "
"instância,\n"
"bem como por qualquer outro usuário do objeto (também chamados \"clientes\" "
"do\n"
"objeto). Em outras palavras, classes não servem para implementar tipos\n"
"puramente abstratos de dados. De fato, nada em Python torna possível "
"assegurar\n"
"o encapsulamento de dados --- tudo é convenção. (Por outro lado, a\n"
"implementação de Python, escrita em C, pode esconder completamente detalhes "
"de\n"
"um objeto ou controlar seu acesso, se necessário; isto pode ser utilizado "
"por\n"
"extensões de Python escritas em C.)"

#: ../../tutorial/classes.rst:493
msgid ""
"Clients should use data attributes with care --- clients may mess up "
"invariants maintained by the methods by stamping on their data attributes.  "
"Note that clients may add data attributes of their own to an instance object "
"without affecting the validity of the methods, as long as name conflicts are "
"avoided --- again, a naming convention can save a lot of headaches here."
msgstr ""
"Clientes devem utilizar atributos de dados com cuidado, pois podem bagunçar\n"
"invariantes assumidas pelos métodos ao esbarrar em seus atributos de dados.\n"
"Note que clientes podem adicionar à vontade atributos de dados a uma "
"instância\n"
"sem afetar a validade dos métodos, desde que seja evitado o conflito de "
"nomes.\n"
"Novamente, uma convenção de nomenclatura poupa muita dor de cabeça."

#: ../../tutorial/classes.rst:499
msgid ""
"There is no shorthand for referencing data attributes (or other methods!) "
"from within methods.  I find that this actually increases the readability of "
"methods: there is no chance of confusing local variables and instance "
"variables when glancing through a method."
msgstr ""
"Não existe atalho para referenciar atributos de dados (ou outros métodos!) "
"de\n"
"dentro de um método: sempre é preciso fazer referência explícita ao ``self."
"``\n"
"para acessar qualquer atributo da instância. Em minha opinião isso aumenta "
"a\n"
"legibilidade dos métodos: não há como confundir uma variável local com um\n"
"atributo da instância quando lemos rapidamente um método desconhecido."

#: ../../tutorial/classes.rst:504
msgid ""
"Often, the first argument of a method is called ``self``.  This is nothing "
"more than a convention: the name ``self`` has absolutely no special meaning "
"to Python.  Note, however, that by not following the convention your code "
"may be less readable to other Python programmers, and it is also conceivable "
"that a *class browser* program might be written that relies upon such a "
"convention."
msgstr ""
"Frequentemente, o primeiro argumento de um método é chamado ``self``. Isso "
"não\n"
"passa de uma convenção: o identificador ``self`` não é uma palavra "
"reservada\n"
"nem possui qualquer significado especial em Python. Mas note que, ao seguir\n"
"essa convenção, seu código se torna legível por uma grande comunidade de\n"
"desenvolvedores Python e é possível que alguma *IDE* dependa dessa "
"convenção\n"
"para analisar seu código."

#: ../../tutorial/classes.rst:510
msgid ""
"Any function object that is a class attribute defines a method for instances "
"of that class.  It is not necessary that the function definition is "
"textually enclosed in the class definition: assigning a function object to a "
"local variable in the class is also ok.  For example::"
msgstr ""
"Qualquer objeto função que é atributo de uma classe, define um método para "
"as\n"
"instâncias desta classe. Não é necessário que a definição da função esteja\n"
"textualmente embutida na definição da classe. Atribuir um objeto função a "
"uma\n"
"variável local da classe é válido. Por exemplo::"

#: ../../tutorial/classes.rst:527
msgid ""
"Now ``f``, ``g`` and ``h`` are all attributes of class :class:`C` that refer "
"to function objects, and consequently they are all methods of instances of :"
"class:`C` --- ``h`` being exactly equivalent to ``g``.  Note that this "
"practice usually only serves to confuse the reader of a program."
msgstr ""
"Agora ``f``, ``g`` e ``h`` são todos atributos da classe :class:`C` que\n"
"referenciam funções, e consequentemente são todos métodos de instâncias da\n"
"classe :class:`C`, onde ``h`` é equivalente a ``g``. No entanto, essa "
"prática\n"
"serve apenas para confundir o leitor do programa."

#: ../../tutorial/classes.rst:532
msgid ""
"Methods may call other methods by using method attributes of the ``self`` "
"argument::"
msgstr ""
"Métodos podem invocar outros métodos usando atributos de método do argumento "
"``self`` ::"

#: ../../tutorial/classes.rst:546
msgid ""
"Methods may reference global names in the same way as ordinary functions.  "
"The global scope associated with a method is the module containing its "
"definition.  (A class is never used as a global scope.)  While one rarely "
"encounters a good reason for using global data in a method, there are many "
"legitimate uses of the global scope: for one thing, functions and modules "
"imported into the global scope can be used by methods, as well as functions "
"and classes defined in it.  Usually, the class containing the method is "
"itself defined in this global scope, and in the next section we'll find some "
"good reasons why a method would want to reference its own class."
msgstr ""
"Métodos podem referenciar nomes globais da mesma forma que funções comuns. "
"O\n"
"escopo global associado a um método é o módulo contendo sua a definição de "
"sua\n"
"classe (a classe propriamente dita nunca é usada como escopo global!). "
"Ainda\n"
"que seja raro justificar o uso de dados globais em um método, há diversos "
"usos\n"
"legítimos do escopo global. Por exemplo, funções e módulos importados no\n"
"escopo global podem ser usados por métodos, bem como as funções e classes\n"
"definidas no próprio escopo global. Provavelmente, a classe contendo o "
"método\n"
"em questão também foi definida neste escopo global. Na próxima seção "
"veremos\n"
"razões pelas quais um método pode querer referenciar sua própria classe."

#: ../../tutorial/classes.rst:556
msgid ""
"Each value is an object, and therefore has a *class* (also called its "
"*type*). It is stored as ``object.__class__``."
msgstr ""
"Cada valor é um objeto e, portanto, tem uma *classe* (também chamada de "
"*tipo*). Ela é armazenada como um ``object .__ class__``."

#: ../../tutorial/classes.rst:563
msgid "Inheritance"
msgstr "Herança"

#: ../../tutorial/classes.rst:565
msgid ""
"Of course, a language feature would not be worthy of the name \"class\" "
"without supporting inheritance.  The syntax for a derived class definition "
"looks like this::"
msgstr ""
"Obviamente, uma característica não seria digna do nome \"classe\" se não\n"
"suportasse herança. A sintaxe para uma classe derivada é assim::"

#: ../../tutorial/classes.rst:576
msgid ""
"The name :class:`BaseClassName` must be defined in a scope containing the "
"derived class definition.  In place of a base class name, other arbitrary "
"expressions are also allowed.  This can be useful, for example, when the "
"base class is defined in another module::"
msgstr ""
"O identificador :class:`NomeClasseBase` deve estar definido no escopo que\n"
"contém a definição da classe derivada. No lugar do nome da classe base, "
"também\n"
"são aceitas outras expressões. Isso é muito útil, por exemplo, quando a "
"classe\n"
"base é definida em outro módulo::"

#: ../../tutorial/classes.rst:583
msgid ""
"Execution of a derived class definition proceeds the same as for a base "
"class. When the class object is constructed, the base class is remembered.  "
"This is used for resolving attribute references: if a requested attribute is "
"not found in the class, the search proceeds to look in the base class.  This "
"rule is applied recursively if the base class itself is derived from some "
"other class."
msgstr ""
"A execução de uma definição de classe derivada procede da mesma forma que a "
"de\n"
"uma classe base. Quando o objeto classe é construído, a classe base é\n"
"lembrada. Isso é utilizado para resolver referências a atributos. Se um\n"
"atributo requisitado não for encontrado na classe, ele é procurado na "
"classe\n"
"base. Essa regra é aplicada recursivamente se a classe base por sua vez for\n"
"derivada de outra."

#: ../../tutorial/classes.rst:589
msgid ""
"There's nothing special about instantiation of derived classes: "
"``DerivedClassName()`` creates a new instance of the class.  Method "
"references are resolved as follows: the corresponding class attribute is "
"searched, descending down the chain of base classes if necessary, and the "
"method reference is valid if this yields a function object."
msgstr ""
"Não há nada de especial sobre instanciação de classes derivadas.\n"
"``NomeClasseDerivada()`` cria uma nova instância da classe. Referências a\n"
"métodos são resolvidas da seguinte forma: o atributo correspondente é\n"
"procurado através da cadeia de classes base, e referências a métodos são\n"
"válidas desde se essa procura produza um objeto função."

#: ../../tutorial/classes.rst:595
msgid ""
"Derived classes may override methods of their base classes.  Because methods "
"have no special privileges when calling other methods of the same object, a "
"method of a base class that calls another method defined in the same base "
"class may end up calling a method of a derived class that overrides it.  "
"(For C++ programmers: all methods in Python are effectively ``virtual``.)"
msgstr ""
"Classes derivadas podem sobrescrever métodos das suas classes base. Uma vez\n"
"que métodos não possuem privilégios especiais quando invocam outros métodos\n"
"no mesmo objeto, um método na classe base que invocava um outro método da\n"
"mesma classe base, pode efetivamente acabar invocando um método sobreposto "
"por\n"
"uma classe derivada. (Para programadores C++ isso significa que todos os\n"
"métodos em Python são realmente virtuais.)"

#: ../../tutorial/classes.rst:601
msgid ""
"An overriding method in a derived class may in fact want to extend rather "
"than simply replace the base class method of the same name. There is a "
"simple way to call the base class method directly: just call ``BaseClassName."
"methodname(self, arguments)``.  This is occasionally useful to clients as "
"well.  (Note that this only works if the base class is accessible as "
"``BaseClassName`` in the global scope.)"
msgstr ""

#: ../../tutorial/classes.rst:608
msgid "Python has two built-in functions that work with inheritance:"
msgstr "Python tem duas funções embutidas que trabalham com herança:"

#: ../../tutorial/classes.rst:610
msgid ""
"Use :func:`isinstance` to check an instance's type: ``isinstance(obj, int)`` "
"will be ``True`` only if ``obj.__class__`` is :class:`int` or some class "
"derived from :class:`int`."
msgstr ""
"* Use :func:`isinstance` para verificar o tipo de uma instância:\n"
" ``isinstance(obj, int)`` será ``True`` somente se ``obj.__class__`` é\n"
" a classe :class:`int` ou alguma classe derivada de :class:`int`."

#: ../../tutorial/classes.rst:614
msgid ""
"Use :func:`issubclass` to check class inheritance: ``issubclass(bool, int)`` "
"is ``True`` since :class:`bool` is a subclass of :class:`int`.  However, "
"``issubclass(float, int)`` is ``False`` since :class:`float` is not a "
"subclass of :class:`int`."
msgstr ""
"* Use :func:`issubclass` para verificar herança entre classes:\n"
" ``issubclass(bool, int)`` é ``True`` porque :class:`bool` é uma subclasse\n"
" de :class:`int`. Entretanto, ``issubclass(unicode, str)`` é ``False``\n"
" porque :class:`unicode` não é uma subclasse :class:`str` (essas duas "
"classes\n"
" derivam da mesma classe base: :class:`basestring`)."

#: ../../tutorial/classes.rst:624
msgid "Multiple Inheritance"
msgstr "Herança Múltipla"

#: ../../tutorial/classes.rst:626
msgid ""
"Python supports a form of multiple inheritance as well.  A class definition "
"with multiple base classes looks like this::"
msgstr ""
"Python também suporta uma forma limitada de herança múltipla. Uma definição "
"de\n"
"classe com várias classes base tem esta forma::"

#: ../../tutorial/classes.rst:636
msgid ""
"For most purposes, in the simplest cases, you can think of the search for "
"attributes inherited from a parent class as depth-first, left-to-right, not "
"searching twice in the same class where there is an overlap in the "
"hierarchy. Thus, if an attribute is not found in :class:`DerivedClassName`, "
"it is searched for in :class:`Base1`, then (recursively) in the base classes "
"of :class:`Base1`, and if it was not found there, it was searched for in :"
"class:`Base2`, and so on."
msgstr ""

#: ../../tutorial/classes.rst:643
msgid ""
"In fact, it is slightly more complex than that; the method resolution order "
"changes dynamically to support cooperative calls to :func:`super`.  This "
"approach is known in some other multiple-inheritance languages as call-next-"
"method and is more powerful than the super call found in single-inheritance "
"languages."
msgstr ""

#: ../../tutorial/classes.rst:649
msgid ""
"Dynamic ordering is necessary because all cases of multiple inheritance "
"exhibit one or more diamond relationships (where at least one of the parent "
"classes can be accessed through multiple paths from the bottommost class).  "
"For example, all classes inherit from :class:`object`, so any case of "
"multiple inheritance provides more than one path to reach :class:`object`.  "
"To keep the base classes from being accessed more than once, the dynamic "
"algorithm linearizes the search order in a way that preserves the left-to-"
"right ordering specified in each class, that calls each parent only once, "
"and that is monotonic (meaning that a class can be subclassed without "
"affecting the precedence order of its parents). Taken together, these "
"properties make it possible to design reliable and extensible classes with "
"multiple inheritance.  For more detail, see https://www.python.org/download/"
"releases/2.3/mro/."
msgstr ""

#: ../../tutorial/classes.rst:666
msgid "Private Variables"
msgstr "Variáveis Privadas"

#: ../../tutorial/classes.rst:668
msgid ""
"\"Private\" instance variables that cannot be accessed except from inside an "
"object don't exist in Python.  However, there is a convention that is "
"followed by most Python code: a name prefixed with an underscore (e.g. "
"``_spam``) should be treated as a non-public part of the API (whether it is "
"a function, a method or a data member).  It should be considered an "
"implementation detail and subject to change without notice."
msgstr ""
"Variáveis instância \"privadas\", que não podem ser acessados ​​exceto em\n"
"métodos do próprio objeto não existem em Python. No entanto, existe uma\n"
"convenção que é seguida pela maioria dos programas em Python: um nome\n"
"prefixado com um sublinhado (por exemplo: ``_spam`` ) deve ser tratado como\n"
"uma parte não-pública da API (seja ele uma função, um método ou um atributo "
"de\n"
"dados). Tais nomes devem ser considerados um detalhe de implementação e\n"
"sujeito a alteração sem aviso prévio."

#: ../../tutorial/classes.rst:678
msgid ""
"Since there is a valid use-case for class-private members (namely to avoid "
"name clashes of names with names defined by subclasses), there is limited "
"support for such a mechanism, called :dfn:`name mangling`.  Any identifier "
"of the form ``__spam`` (at least two leading underscores, at most one "
"trailing underscore) is textually replaced with ``_classname__spam``, where "
"``classname`` is the current class name with leading underscore(s) "
"stripped.  This mangling is done without regard to the syntactic position of "
"the identifier, as long as it occurs within the definition of a class."
msgstr ""
"Uma vez que existe um caso de uso válido para a definição de atributos\n"
"privados em classes (especificamente para evitar conflitos com nomes "
"definidos\n"
"em subclasses), existe um suporte limitado a identificadores privados em\n"
"classes, chamado :dfn:`name mangling` (literalmente: desfiguração de "
"nomes).\n"
"Qualquer identificador no formato ``__spam`` (no mínimo dois underscores "
"``_``\n"
"no prefixo e no máximo um sufixo) é substituído por ``_nomeclasse__spam``,\n"
"onde ``nomeclasse`` é o nome da classe corrente (exceto quando o nome da "
"classe\n"
"é prefixado com um ou mais underscores ``_``; nesse caso eles são "
"omitidos).\n"
"Essa desfiguração independe da posição sintática do identificador, desde "
"que\n"
"ele apareça dentro da definição de uma classe."

#: ../../tutorial/classes.rst:687
msgid ""
"Name mangling is helpful for letting subclasses override methods without "
"breaking intraclass method calls.  For example::"
msgstr ""
"A desfiguração de nomes é útil para que subclasses possam sobrescrever "
"métodos\n"
"sem quebrar invocações de métodos dentro de outra classe. Por exemplo::"

#: ../../tutorial/classes.rst:709
msgid ""
"The above example would work even if ``MappingSubclass`` were to introduce a "
"``__update`` identifier since it is replaced with ``_Mapping__update`` in "
"the ``Mapping`` class  and ``_MappingSubclass__update`` in the "
"``MappingSubclass`` class respectively."
msgstr ""

#: ../../tutorial/classes.rst:714
msgid ""
"Note that the mangling rules are designed mostly to avoid accidents; it "
"still is possible to access or modify a variable that is considered "
"private.  This can even be useful in special circumstances, such as in the "
"debugger."
msgstr ""
"Note que as regras de desfiguração de nomes foram projetadas para evitar\n"
"acidentes; ainda é possível acessar e alterar intencionalmente variáveis\n"
"protegidas por esse mecanismo. De fato isso pode ser útil em certas\n"
"circunstâncias, por exemplo, durante uma sessão com o :mod:`pdb`, o\n"
"depurador interativo do Python."

#: ../../tutorial/classes.rst:718
msgid ""
"Notice that code passed to ``exec()`` or ``eval()`` does not consider the "
"classname of the invoking class to be the current class; this is similar to "
"the effect of the ``global`` statement, the effect of which is likewise "
"restricted to code that is byte-compiled together.  The same restriction "
"applies to ``getattr()``, ``setattr()`` and ``delattr()``, as well as when "
"referencing ``__dict__`` directly."
msgstr ""
"Código passado para ``exec``, ``eval()`` ou ``execfile()`` não considera o\n"
"nome da classe que invocou como sendo a classe corrente; isso é semelhante "
"ao\n"
"funcionamento da declaração :keyword:`global`, cujo efeito se aplica "
"somente\n"
"ao código que é byte-compilado junto. A mesma restrição se aplica as "
"funções\n"
"``getattr()``, ``setattr()`` e ``delattr()``, e quando acessamos diretamente "
"o\n"
"``__dict__`` da classe: lá as chaves já estão desfiguradas."

#: ../../tutorial/classes.rst:729
msgid "Odds and Ends"
msgstr "Odds e Ends"

#: ../../tutorial/classes.rst:731
msgid ""
"Sometimes it is useful to have a data type similar to the Pascal \"record\" "
"or C \"struct\", bundling together a few named data items.  An empty class "
"definition will do nicely::"
msgstr ""
"Às vezes, é útil ter um tipo semelhante ao \"record\" de Pascal ou ao "
"\"struct\"\n"
"de C, para agrupar alguns itens de dados. Uma definição de classe vazia\n"
"funciona bem para este fim::"

#: ../../tutorial/classes.rst:745
msgid ""
"A piece of Python code that expects a particular abstract data type can "
"often be passed a class that emulates the methods of that data type "
"instead.  For instance, if you have a function that formats some data from a "
"file object, you can define a class with methods :meth:`read` and :meth:`!"
"readline` that get the data from a string buffer instead, and pass it as an "
"argument."
msgstr ""
"Um trecho de código Python que espera um tipo abstrato de dado em "
"particular,\n"
"pode receber, ao invés disso, um objeto que emula os métodos que aquele "
"tipo\n"
"suporta. Por exemplo, se você tem uma função que formata dados obtidos de "
"um\n"
"objeto arquivo, pode passar como argumento para essa função uma instância "
"de\n"
"uma classe que implemente os métodos :meth:`read` e :meth:`readline` que "
"obtém\n"
"os dados lendo um buffer ao invés de ler um arquivo real. (N.d.T. isso é um\n"
"exemplo de \"duck typing\" [#]_\\ .)"

#: ../../tutorial/classes.rst:756
msgid ""
"Instance method objects have attributes, too: ``m.__self__`` is the instance "
"object with the method :meth:`m`, and ``m.__func__`` is the function object "
"corresponding to the method."
msgstr ""
"Objetos método têm seus próprios atributos: ``m.im_self`` é uma referência "
"à\n"
"instância vinculada ao método :meth:`m`, e ``m.im_func`` é o objeto função\n"
"(atributo da classe) que corresponde ao método."

#: ../../tutorial/classes.rst:764
msgid "Iterators"
msgstr "Iteradores"

#: ../../tutorial/classes.rst:766
msgid ""
"By now you have probably noticed that most container objects can be looped "
"over using a :keyword:`for` statement::"
msgstr ""
"Você já deve ter notado que pode usar laços :keyword:`for` com a maioria "
"das\n"
"coleções em Python::"

#: ../../tutorial/classes.rst:780
msgid ""
"This style of access is clear, concise, and convenient.  The use of "
"iterators pervades and unifies Python.  Behind the scenes, the :keyword:"
"`for` statement calls :func:`iter` on the container object.  The function "
"returns an iterator object that defines the method :meth:`~iterator."
"__next__` which accesses elements in the container one at a time.  When "
"there are no more elements, :meth:`~iterator.__next__` raises a :exc:"
"`StopIteration` exception which tells the :keyword:`!for` loop to "
"terminate.  You can call the :meth:`~iterator.__next__` method using the :"
"func:`next` built-in function; this example shows how it all works::"
msgstr ""

#: ../../tutorial/classes.rst:805
msgid ""
"Having seen the mechanics behind the iterator protocol, it is easy to add "
"iterator behavior to your classes.  Define an :meth:`__iter__` method which "
"returns an object with a :meth:`~iterator.__next__` method.  If the class "
"defines :meth:`__next__`, then :meth:`__iter__` can just return ``self``::"
msgstr ""
"Observando o mecanismo por trás do protocolo dos iteradores, fica fácil\n"
"adicionar esse comportamento às suas classes. Defina uma método\n"
":meth:`__iter__` que devolve um objeto que tenha um método :meth:`next`. Se\n"
"uma classe já define :meth:`next`, então :meth:`__iter__` pode simplesmente\n"
"devolver ``self``::"

#: ../../tutorial/classes.rst:842
msgid "Generators"
msgstr "Geradores"

#: ../../tutorial/classes.rst:844
msgid ""
":term:`Generator`\\s are a simple and powerful tool for creating iterators.  "
"They are written like regular functions but use the :keyword:`yield` "
"statement whenever they want to return data.  Each time :func:`next` is "
"called on it, the generator resumes where it left off (it remembers all the "
"data values and which statement was last executed).  An example shows that "
"generators can be trivially easy to create::"
msgstr ""
"Funções geradoras (:term:`generator <generator>`) são uma maneira fácil e\n"
"poderosa de criar um iterador. Uma função geradora é escrita como uma "
"função\n"
"normal, mas usa o comando :keyword:`yield` para produzir resultados. (N.d."
"T.\n"
"Quando invocada, a função geradora produz um objeto gerador.) Cada vez que\n"
":meth:`next` é invocado, o gerador continua a partir de onde parou (ele "
"mantem\n"
"na memória seus dados internos e a próxima instrução a ser executada). Um\n"
"exemplo mostra como geradores podem ser muito fáceis de criar::"

#: ../../tutorial/classes.rst:865
msgid ""
"Anything that can be done with generators can also be done with class-based "
"iterators as described in the previous section.  What makes generators so "
"compact is that the :meth:`__iter__` and :meth:`~generator.__next__` methods "
"are created automatically."
msgstr ""
"Qualquer coisa feita com geradores também pode ser feita com iteradores\n"
"baseados numa classe, como descrito na seção anterior. O que torna "
"geradores\n"
"tão compactos é que os métodos :meth:`__iter__` e :meth:`next` são criados\n"
"automaticamente."

#: ../../tutorial/classes.rst:870
msgid ""
"Another key feature is that the local variables and execution state are "
"automatically saved between calls.  This made the function easier to write "
"and much more clear than an approach using instance variables like ``self."
"index`` and ``self.data``."
msgstr ""
"Outro ponto chave é que as variáveis locais e o estado da execução são\n"
"preservados automaticamente entre as chamadas de :meth:`next`. Isto torna a\n"
"função mais fácil de escrever e muito mais clara do que uma implementação\n"
"usando variáveis de instância como ``self.index`` e ``self.data``."

#: ../../tutorial/classes.rst:875
msgid ""
"In addition to automatic method creation and saving program state, when "
"generators terminate, they automatically raise :exc:`StopIteration`. In "
"combination, these features make it easy to create iterators with no more "
"effort than writing a regular function."
msgstr ""
"Além disso, quando geradores terminam, eles levantam :exc:`StopIteration`\n"
"automaticamente. Combinados, todos estes aspectos tornam a criação de\n"
"iteradores tão fácil quanto escrever uma função normal."

#: ../../tutorial/classes.rst:884
msgid "Generator Expressions"
msgstr "Expressões GeradorAS"

#: ../../tutorial/classes.rst:886
msgid ""
"Some simple generators can be coded succinctly as expressions using a syntax "
"similar to list comprehensions but with parentheses instead of square "
"brackets. These expressions are designed for situations where the generator "
"is used right away by an enclosing function.  Generator expressions are more "
"compact but less versatile than full generator definitions and tend to be "
"more memory friendly than equivalent list comprehensions."
msgstr ""

#: ../../tutorial/classes.rst:893
msgid "Examples::"
msgstr "Exemplos::"

#: ../../tutorial/classes.rst:917
msgid "Footnotes"
msgstr "Notas de Rodapé"

#: ../../tutorial/classes.rst:918
msgid ""
"Except for one thing.  Module objects have a secret read-only attribute "
"called :attr:`~object.__dict__` which returns the dictionary used to "
"implement the module's namespace; the name :attr:`~object.__dict__` is an "
"attribute but not a global name. Obviously, using this violates the "
"abstraction of namespace implementation, and should be restricted to things "
"like post-mortem debuggers."
msgstr ""
"Exceto por uma coisa. Os objetos de módulo têm um atributo secreto e de  "
"somente leitura chamado :attr:`~objeto.__ dict__` que retorna o dicionário "
"usado para implementar o namespace do módulo; O nome :attr:`~objeto."
"__dict__` é um atributo, mas não um nome global. Obviamente, usar isso viola "
"a abstração da implementação do namespace, e deve ser restrito a coisas como "
"depuradores post-mortem."
